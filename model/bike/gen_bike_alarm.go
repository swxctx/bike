// generated by ginpt
package bike

import (
	"bytes"
	"database/sql"
	"fmt"
	"time"

	"github.com/domego/ginkits/db"
	"github.com/domego/ginkits/redis"
	"github.com/domego/gokits"
	"github.com/domego/gokits/log"
	"github.com/domego/gorp"
)

var _ = time.Now
var _ = fmt.Println
var _ = sql.ErrNoRows
var _ = bytes.NewBuffer
var _ = utils.Int32

type BikeAlarm struct {
	Id         int32     `db:"id" json:"id"`
	ById       int32     `db:"by_id" json:"by_id"`
	MhCountOne int32     `db:"mh_count_one" json:"mh_count_one"`
	MhCountTwo int32     `db:"mh_count_two" json:"mh_count_two"`
	SwCountOne int32     `db:"sw_count_one" json:"sw_count_one"`
	SwCountTwo int32     `db:"sw_count_two" json:"sw_count_two"`
	AlarmTs    int64     `db:"alarm_ts" json:"alarm_ts"`
	CreatedAt  time.Time `db:"created_at" json:"created_at"`
	UpdatedAt  time.Time `db:"updated_at" json:"updated_at"`
	Deleted    byte      `db:"deleted" json:"deleted"`

	_db *db.DBInfo      `db:"-"`
	_tx *db.Transaction `db:"-"`
}

func NewBikeAlarm() *BikeAlarm {
	obj := NewBikeAlarmWithoutDB()
	obj.SetDBInfo()
	return obj
}

func NewBikeAlarmWithoutDB() *BikeAlarm {
	obj := &BikeAlarm{}
	return obj
}

func (obj *BikeAlarm) SetDBInfo() {
	database := GetDB()
	obj._db = &db.DBInfo{
		DB:    database.DB,
		DbMap: database.DbMap,
	}
}

func (obj *BikeAlarm) SetTransaction(tx *db.Transaction) {
	obj._tx = tx
}

func (obj *BikeAlarm) GetSqlExecutor() gorp.SqlExecutor {
	if obj._tx != nil {
		return obj._tx
	}
	return obj._db
}

func (obj *BikeAlarm) PrimaryCacheKey() string {
	return fmt.Sprintf("bike:orm:bike_alarm:id:%v", obj.Id)
}

func (obj *BikeAlarm) SaveToCache() error {
	if RedisClient != nil {
		return rediskits.SetModelToCache(RedisClient, obj.PrimaryCacheKey(), obj, DefaultCacheTTL)
	}
	return nil
}

func (obj *BikeAlarm) DeleteCache() error {
	if RedisClient != nil {
		return rediskits.DeleteCache(RedisClient, obj.PrimaryCacheKey(), 3)
	}
	return nil
}

func (obj *BikeAlarm) Insert() {
	database := obj.GetSqlExecutor()

	obj.CreatedAt = time.Now()

	obj.UpdatedAt = time.Now()

	err := database.Insert(obj)
	if err != nil {
		panic(err)
	}
	if err = obj.SaveToCache(); err != nil {
		log.Errorf("[CacheKey:%s], %s", obj.PrimaryCacheKey(), err)
	}
}

func (obj *BikeAlarm) Update() {
	var err error
	database := obj.GetSqlExecutor()

	obj.UpdatedAt = time.Now()

	_, err = database.Update(obj)
	if err != nil {
		panic(err)
	}
	if err = obj.SaveToCache(); err != nil {
		log.Errorf("[CacheKey:%s], %s", obj.PrimaryCacheKey(), err)
	}
}

func (obj *BikeAlarm) Delete() {

	obj.Deleted = 1

	obj.Update()

}

func GetBikeAlarmWhere(cond string, args ...interface{}) []*BikeAlarm {
	objs := []*BikeAlarm{}
	database := GetDB()
	_, err := database.Select(&objs, "SELECT `id`, `by_id`, `mh_count_one`, `mh_count_two`, `sw_count_one`, `sw_count_two`, `alarm_ts`, `created_at`, `updated_at`, `deleted` FROM `bike_alarm` WHERE "+cond, args...)
	if err != nil {
		panic(err)
	}
	for _, obj := range objs {
		obj.SetDBInfo()
	}
	return objs
}

func GetBikeAlarmCount(cond string, args ...interface{}) int64 {
	database := GetDB()
	cnt, err := database.SelectInt("SELECT count(1) FROM `bike_alarm` WHERE "+cond, args...)
	if err != nil {
		panic(err)
	}
	return cnt
}

func GetBikeAlarmFirst(cond string, args ...interface{}) *BikeAlarm {
	obj := &BikeAlarm{}
	database := GetDB()
	err := database.SelectOne(obj, "SELECT `id`, `by_id`, `mh_count_one`, `mh_count_two`, `sw_count_one`, `sw_count_two`, `alarm_ts`, `created_at`, `updated_at`, `deleted` FROM `bike_alarm` WHERE "+cond+" LIMIT 1", args...)
	if err != nil {
		if err.Error() == sql.ErrNoRows.Error() {
			return nil
		}
		panic(err)
	}
	obj.SetDBInfo()
	return obj
}

func GetBikeAlarmByField(name string, field interface{}) *BikeAlarm {
	obj := &BikeAlarm{}
	database := GetDB()
	err := database.SelectOne(obj, "SELECT `id`, `by_id`, `mh_count_one`, `mh_count_two`, `sw_count_one`, `sw_count_two`, `alarm_ts`, `created_at`, `updated_at`, `deleted` FROM `bike_alarm` WHERE `"+name+"`=?", field)
	if err != nil {
		if err.Error() == sql.ErrNoRows.Error() {
			return nil
		}
		panic(err)
	}
	obj.SetDBInfo()
	return obj
}

func GetBikeAlarmByFieldWithCondition(name, cond string, field interface{}) *BikeAlarm {
	obj := &BikeAlarm{}
	database := GetDB()
	err := database.SelectOne(obj, "SELECT `id`, `by_id`, `mh_count_one`, `mh_count_two`, `sw_count_one`, `sw_count_two`, `alarm_ts`, `created_at`, `updated_at`, `deleted` FROM `bike_alarm` WHERE `"+name+"`=? "+cond, field)
	if err != nil {
		if err.Error() == sql.ErrNoRows.Error() {
			return nil
		}
		panic(err)
	}
	obj.SetDBInfo()
	return obj
}

func GetBikeAlarm(key int32) *BikeAlarm {
	obj := &BikeAlarm{}
	var notFound = true
	var err error
	if RedisClient != nil {
		obj.Id = key
		notFound = rediskits.GetCacheToModel(RedisClient, obj.PrimaryCacheKey(), obj)
	}
	if notFound {
		database := GetDB()
		err = database.SelectOne(obj, "SELECT `id`, `by_id`, `mh_count_one`, `mh_count_two`, `sw_count_one`, `sw_count_two`, `alarm_ts`, `created_at`, `updated_at`, `deleted` FROM `bike_alarm` WHERE `id`=?", key)
		if err != nil {
			if err.Error() == sql.ErrNoRows.Error() {
				return nil
			}
			panic(err)
		}
	}
	if notFound && RedisClient != nil {
		if err = obj.SaveToCache(); err != nil {
			log.Errorf("[CacheKey:%s], %s", obj.PrimaryCacheKey(), err)
		}
	}
	obj.SetDBInfo()
	return obj
}
